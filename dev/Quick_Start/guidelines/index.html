<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Customization Guidelines · EAGO.jl: Easy Advanced Global Optimization</title><link rel="canonical" href="https://PSORLab.github.io/EAGO.jl/stable/Quick_Start/guidelines/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">EAGO.jl: Easy Advanced Global Optimization</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Quick Start</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../qs_landing/">Quick Start</a></li><li class="is-active"><a class="tocitem" href>Customization Guidelines</a><ul class="internal"><li><a class="tocitem" href="#)-Creating-an-Extension"><span>1) Creating an Extension</span></a></li><li><a class="tocitem" href="#)-Preprocessing"><span>2) Preprocessing</span></a></li><li><a class="tocitem" href="#)-Lower-problem"><span>3) Lower problem</span></a></li><li><a class="tocitem" href="#)-Upper-problem"><span>4) Upper problem</span></a></li><li><a class="tocitem" href="#)-Convergence-check"><span>5) Convergence check</span></a></li><li><a class="tocitem" href="#)-Postprocessing"><span>6) Postprocessing</span></a></li><li><a class="tocitem" href="#)-Termination-check"><span>7) Termination check</span></a></li><li><a class="tocitem" href="#References:"><span>References:</span></a></li></ul></li><li><a class="tocitem" href="../starting/">Simple Example</a></li><li><a class="tocitem" href="../medium/">Simple Example</a></li><li><a class="tocitem" href="../custom/">Simple Example</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">McCormick Operator Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../McCormick/overview/">Overview</a></li><li><a class="tocitem" href="../../McCormick/usage/">Basic Usage</a></li><li><a class="tocitem" href="../../McCormick/operators/">Currently supported operators</a></li><li><a class="tocitem" href="../../McCormick/type/">Types</a></li><li><a class="tocitem" href="../../McCormick/implicit/">Relaxation of Implicit Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Global Optimizer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Optimizer/optimizer/">EAGO Optimizer</a></li><li><a class="tocitem" href="../../Optimizer/bnb_back/">EAGO&#39;s Branch and Bound Routine</a></li><li><a class="tocitem" href="../../Optimizer/relax_back/">Nonlinear Backend</a></li><li><a class="tocitem" href="../../Optimizer/domain_reduction/">Domain Reduction</a></li><li><a class="tocitem" href="../../Optimizer/high_performance/">High-Performance Configuration</a></li><li><a class="tocitem" href="../../Optimizer/udf_utilities/">User-Define Functions and DAG Utilities</a></li></ul></li><li><a class="tocitem" href="../../SemiInfinite/semiinfinite/">Semi-Infinite Programming</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Contributing to EAGO</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Dev/contributing/">How to Contribute</a></li><li><a class="tocitem" href="../../Dev/future/">Future Work</a></li></ul></li><li><a class="tocitem" href="../../ref/">References</a></li><li><a class="tocitem" href="../../cite/">Citing EAGO</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Quick Start</a></li><li class="is-active"><a href>Customization Guidelines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Customization Guidelines</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PSORLab/EAGO.jl/blob/master/docs/src/Quick_Start/guidelines.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Customization-Guidelines"><a class="docs-heading-anchor" href="#Customization-Guidelines">Customization Guidelines</a><a id="Customization-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Customization-Guidelines" title="Permalink"></a></h1><p>This section contains general guidelines on how the functionality of EAGO can be extended for specific use cases. Many functions in EAGO are extensible, so examples are not provided for every possible case, but some important functions are covered. If there is a use case you do not see provided here, but would like to see, please contact <a href="https://psor.uconn.edu/person/robert-gottlieb/">Robert Gottlieb</a>.</p><h2 id=")-Creating-an-Extension"><a class="docs-heading-anchor" href="#)-Creating-an-Extension">1) Creating an Extension</a><a id=")-Creating-an-Extension-1"></a><a class="docs-heading-anchor-permalink" href="#)-Creating-an-Extension" title="Permalink"></a></h2><p>Extensibility in EAGO is based on the <code>EAGO.ExtensionType</code> type. To create customized functions, the recommended method is to create a new structure, as follows:</p><pre><code class="language-julia">using EAGO

struct MyNewStruct &lt;: EAGO.ExtensionType end</code></pre><p>To let EAGO know that you would like to use this extension (and any functions you overload), when you create the JuMP model, declare your new type in the SubSolvers field of EAGO&#39;s optimizer as follows:</p><pre><code class="language-julia">using JuMP

factory = () -&gt; EAGO.Optimizer(SubSolvers(; t = MyNewStruct() ))
model = Model(factory)</code></pre><p>The key point to note here is that the new structure is set to <code>SubSolvers.t</code>, which is the field that holds any user-defined extension type. Now, when EAGO calls any of its functions, it will check to see if a custom function for this new extension has been created. If so, it will use the new one; if not, it will use the default version of that function.</p><h2 id=")-Preprocessing"><a class="docs-heading-anchor" href="#)-Preprocessing">2) Preprocessing</a><a id=")-Preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#)-Preprocessing" title="Permalink"></a></h2><p>In EAGO&#39;s branch-and-bound routine, preprocessing is performed prior to solving the lower and upper problems. By default, linear and quadratic contractor methods are performed, followed by interval constraint propagation, then optimization-based bounds tightening. An important outcome of EAGO&#39;s default preprocessing is that the <code>_preprocess_feasibility</code> field of the <code>EAGO.GlobalOptimizer</code> is set to <code>true</code>, unless the subproblem at the current node has been proven infeasible. Therefore, to bypass preprocessing for your own problem, you must, at a minimum, set this field to <code>true</code>. For example:</p><pre><code class="language-julia">import EAGO: preprocess!
function EAGO.preprocess!(t::MyNewStruct, x::EAGO.GlobalOptimizer)
    x._preprocess_feasibility = true
end</code></pre><p>The user-defined preprocessing step can be as simple or complex as desired, but if <code>_preprocess_feasibility</code> is not set to <code>true</code>, EAGO will assume each node is infeasible.</p><h2 id=")-Lower-problem"><a class="docs-heading-anchor" href="#)-Lower-problem">3) Lower problem</a><a id=")-Lower-problem-1"></a><a class="docs-heading-anchor-permalink" href="#)-Lower-problem" title="Permalink"></a></h2><p>By default, EAGO applies Kelley&#39;s cutting-plane algorithm[1] to solve the lower bounding problem. This can be overloaded using the same syntax as for the other functions. Necessary changes to the <code>EAGO.GlobalOptimizer</code> that occur within the lower problem are changing the <code>_lower_objective_value</code> and <code>_lower_feasibility</code> fields. If the <code>_lower_objective_value</code> field is not changed, branch-and-bound will not update the lower bound. If <code>_lower_feasibility</code> is not set to <code>true</code>, the node will be discarded as infeasible. A minimum functional (though not useful) lower problem extension is as follows:</p><pre><code class="language-julia">import EAGO: lower_problem!
function EAGO.lower_problem!(t::MyNewStruct, x::EAGO.GlobalOptimizer)
    x._lower_objective_value = -Inf
    x._lower_feasibility = true
end</code></pre><p>Any arbitrarily complex lower problem can be substituted here in place of EAGO&#39;s default method, as long as these fields are updated. Note also that, although there is a separate upper problem function, if the lower problem is being replaced by an algorithm that also calculates an upper objective value, the necessary fields to update in <code>upper_problem!</code> can simply be updated here, and the <code>upper_problem!</code> can be overloaded by a function that does <code>nothing</code>.</p><h2 id=")-Upper-problem"><a class="docs-heading-anchor" href="#)-Upper-problem">4) Upper problem</a><a id=")-Upper-problem-1"></a><a class="docs-heading-anchor-permalink" href="#)-Upper-problem" title="Permalink"></a></h2><p>By default, the upper bounding problem is run on every node up to depth <code>upper_bounding_depth</code>, and is triggered with a probability of <code>0.5^(depth - upper_bounding_depth)</code> afterwards for continuous problems. For integer problems, this approach is used in addition to running on every node up to depth <code>upper_bounding_depth + cont_depth</code>, with another trigger of probability <code>0.5^(depth - upper_bounding_depth - cont_depth)</code>. The <code>upper_bounding_depth</code> and <code>cont_depth</code> are fields of <code>GlobalOptimizer._parameters</code> and can be changed from their default values when the JuMP model is created, or at any time afterwards. If any of these trigger conditions are met, the  default EAGO upper problem runs a local NLP solve. </p><p>The important fields to update in the <code>upper_problem!</code> are the <code>_upper_objective_value</code> and <code>_upper_feasibility</code> fields. If <code>_upper_objective_value</code> is not updated, the upper bound in the branch-and-bound algorithm will not update and the problem will not converge. If <code>_upper_feasibility</code> is not set to true, then any changes made to <code>_upper_objective_value</code> will not be updated for each node and the problem will not converge. A minimum functional (though not useful) upper problem extension is as follows:</p><pre><code class="language-julia">import EAGO: upper_problem!
function upper_problem!(t::MyNewStruct, x::EAGO.GlobalOptimizer)
    x._upper_objective_value = Inf
    x._upper_feasibility = true
end</code></pre><p>This example upper problem will set the upper bound on the objective value to <code>Inf</code> for each node. Given that no useful information is provided here, we could also have set <code>x_upper_feasibility</code> to <code>false</code> (or equivalently, remove the line where we set it to <code>true</code>), and the global upper bound would never be updated.</p><p>Note that if the <code>_upper_objective_value</code> is changed elsewhere, such as in the definition for the <code>lower_problem!</code>, the <code>_upper_feasibility</code> flag must be set to <code>true</code>. If this is not done, the change to the <code>_upper_objective_value</code> will be discarded.</p><h2 id=")-Convergence-check"><a class="docs-heading-anchor" href="#)-Convergence-check">5) Convergence check</a><a id=")-Convergence-check-1"></a><a class="docs-heading-anchor-permalink" href="#)-Convergence-check" title="Permalink"></a></h2><p>By default, EAGO checks to see if the lower and upper bounds have converged to within either the absolute or relative tolerance. This method of checking convergence may not be desired if, for example, only the absolute tolerance is relevant, and you want to ensure that the program does not end prematurely due to a relative tolerance limit being reached. The fields to check are <code>_lower_objective_value</code> and <code>_upper_objective_value</code> for the best-identified global lower and upper bounds, respectively. This function should return <code>true</code> if the lower and upper bounds have converged, and <code>false</code> otherwise. An example of how to specify that the convergence  check only use the absolute tolerance is as follows:</p><pre><code class="language-julia">import EAGO: convergence_check
function EAGO.convergence_check(t::MyNewStruct, x::EAGO.GlobalOptimizer)
    gap = (x._upper_objective_value - x._lower_objective_value)
    return (gap &lt;= x._parameters.absolute_tolerance)
end</code></pre><h2 id=")-Postprocessing"><a class="docs-heading-anchor" href="#)-Postprocessing">6) Postprocessing</a><a id=")-Postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#)-Postprocessing" title="Permalink"></a></h2><p>Postprocessing is the final step before a node is branched on. By default, EAGO performs duality-based bounds tightening[2] up to an iteration limit set by <code>dbbt_depth</code> in the <code>GlobalOptimizer._parameters</code> field. The important field to update in postprocessing is <code>_postprocess_feasibility</code>, which must be set to <code>true</code> for EAGO to branch on any given node. The minimum working postprocessing function is therefore:</p><pre><code class="language-julia">import EAGO: postprocess!
function EAGO.postprocess!(t::MyNewStruct, x::EAGO.GlobalOptimizer)
    x._postprocess_feasibility = true
end</code></pre><p>If <code>_postprocess_feasibility</code> is not set to <code>true</code>, no nodes will be branched on.</p><h2 id=")-Termination-check"><a class="docs-heading-anchor" href="#)-Termination-check">7) Termination check</a><a id=")-Termination-check-1"></a><a class="docs-heading-anchor-permalink" href="#)-Termination-check" title="Permalink"></a></h2><p>This is the check that occurs on each iteration of the branch-and-bound algorithm that determines whether the algorithm continues or not. By default, several conditions are checked for such as the satisfaction of absolute or relative tolerances, solution infeasibility, or other specified limits. This function returns <code>true</code> if any of the stopping conditions have been met, and  branch-and-bound should stop, and <code>false</code> otherwise. The important fields to update are <code>_end_state</code>, which takes values of <code>EAGO.GlobalEndState</code>, <code>_termination_status_code</code>, which takes values of <code>MathOptInterface.TerminationStatusCode</code>, and <code>_result_status_code</code>, which takes values of <code>MathOptInterface.ResultStatusCode</code>.  Combined, these fields provide information about the branch-and-bound completion status and result feasibility. </p><p>As an example, suppose we have updated the <code>convergence_check</code> function to only check for absolute tolerance, and based on our knowledge of the problem, this is the only condition we care about, and we know the solution will be optimal. We could then overload the <code>termination_check</code> function as follows:</p><pre><code class="language-julia">import EAGO: termination_check
function EAGO.termination_check(t::MyNewStruct, x::EAGO.GlobalOptimizer)
    flag = EAGO.convergence_check(t, x)
    if flag
        x._end_state = EAGO.GS_OPTIMAL
        x._termination_status_code = MathOptInterface.OPTIMAL
        x._result_status_code = MathOptInterface.FEASIBLE_POINT
    end
    return flag
end</code></pre><h2 id="References:"><a class="docs-heading-anchor" href="#References:">References:</a><a id="References:-1"></a><a class="docs-heading-anchor-permalink" href="#References:" title="Permalink"></a></h2><ol><li>Kelley, J. E. “The Cutting-Plane Method for Solving Convex Programs.” <em>Journal of the Society for Industrial and Applied Mathematics</em>, vol. 8, no. 4, pp. 703–12 (1960). </li><li>Tawarmalani, M., Sahinidis, N. V. &quot;Global optimization of mixed-integer nonlinear programs: A theoretical and computational study.&quot; <em>Math. Program., Ser. A</em>, 99, pp. 563-591 (2004).</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../qs_landing/">« Quick Start</a><a class="docs-footer-nextpage" href="../starting/">Simple Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 12 June 2023 18:36">Monday 12 June 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
