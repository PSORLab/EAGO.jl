<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>EAGO&#39;s Branch and Bound Routine · EAGO.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://PSORLab.github.io/EAGO.jl/stable/optimizer/bnb_back/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="EAGO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">EAGO.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Quick Start</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../quick_start/qs_landing/">Quick Start</a></li><li><a class="tocitem" href="../../quick_start/guidelines/">Customization Guidelines</a></li><li><a class="tocitem" href="../../quick_start/explicit_ann/">Standard-Use Example 1</a></li><li><a class="tocitem" href="../../quick_start/ex2/">Standard-Use Example 2</a></li><li><a class="tocitem" href="../../quick_start/quasiconvex/">Advanced-Use Example 1</a></li><li><a class="tocitem" href="../../quick_start/alpha_bb/">Advanced-Use Example 2</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">McCormick Operator Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../mccormick/overview/">Overview</a></li><li><a class="tocitem" href="../../mccormick/usage/">Basic Usage</a></li><li><a class="tocitem" href="../../mccormick/operators/">Currently Supported Operators</a></li><li><a class="tocitem" href="../../mccormick/type/">Types</a></li><li><a class="tocitem" href="../../mccormick/implicit/">Relaxation of Implicit Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Optimizer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../optimizer/">EAGO Optimizer</a></li><li class="is-active"><a class="tocitem" href>EAGO&#39;s Branch and Bound Routine</a><ul class="internal"><li><a class="tocitem" href="#Branch-and-Bound-Node-Storage"><span>Branch and Bound Node Storage</span></a></li><li class="toplevel"><a class="tocitem" href="#Customizable-Subroutines"><span>Customizable Subroutines</span></a></li><li><a class="tocitem" href="#Stack-Management-Subroutines"><span>Stack Management Subroutines</span></a></li><li><a class="tocitem" href="#Internal-Subproblem-Status-Codes-and-Subsolver-Management"><span>Internal Subproblem Status Codes and Subsolver Management</span></a></li><li><a class="tocitem" href="#Main-Subproblem-and-Termination-Subroutines"><span>Main Subproblem and Termination Subroutines</span></a></li><li><a class="tocitem" href="#Internal-Subroutines"><span>Internal Subroutines</span></a></li><li><a class="tocitem" href="#Functions-for-Generating-Console-Output"><span>Functions for Generating Console Output</span></a></li><li><a class="tocitem" href="#Support-for-Log-Output-at-Each-Iteration"><span>Support for Log Output at Each Iteration</span></a></li><li><a class="tocitem" href="#Interval-Representations-of-Expressions"><span>Interval Representations of Expressions</span></a></li></ul></li><li><a class="tocitem" href="../relax_back/">Nonlinear Backend</a></li><li><a class="tocitem" href="../domain_reduction/">Domain Reduction</a></li><li><a class="tocitem" href="../high_performance/">High-Performance Configuration</a></li><li><a class="tocitem" href="../udf_utilities/">User-Defined Functions (UDFs) and Directed Acyclic Graph (DAG) Utilities</a></li></ul></li><li><a class="tocitem" href="../../semiinfinite/semiinfinite/">Semi-Infinite Programming</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Contributing to EAGO</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../dev/contributing/">How to Contribute</a></li><li><a class="tocitem" href="../../dev/future/">Future Work</a></li></ul></li><li><a class="tocitem" href="../../cite/">Citing EAGO</a></li><li><a class="tocitem" href="../../news/">News</a></li><li><a class="tocitem" href="../../ref/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Optimizer</a></li><li class="is-active"><a href>EAGO&#39;s Branch and Bound Routine</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>EAGO&#39;s Branch and Bound Routine</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PSORLab/EAGO.jl/blob/master/docs/src/optimizer/bnb_back.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="EAGO&#39;s-Branch-and-Bound-Routine"><a class="docs-heading-anchor" href="#EAGO&#39;s-Branch-and-Bound-Routine">EAGO&#39;s Branch and Bound Routine</a><a id="EAGO&#39;s-Branch-and-Bound-Routine-1"></a><a class="docs-heading-anchor-permalink" href="#EAGO&#39;s-Branch-and-Bound-Routine" title="Permalink"></a></h1><p>This component is meant to provide a flexible framework for implementing spatial branch-and-bound based optimization routines in Julia. All components of the branch-and-bound routine can be customized by the individual user: lower bounding problem, upper bounding problem.</p><h2 id="Branch-and-Bound-Node-Storage"><a class="docs-heading-anchor" href="#Branch-and-Bound-Node-Storage">Branch and Bound Node Storage</a><a id="Branch-and-Bound-Node-Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-and-Bound-Node-Storage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.NodeBB" href="#EAGO.NodeBB"><code>EAGO.NodeBB</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NodeBB</code></pre><p>Store information associated with each node in the branch-and-bound tree.</p><ul><li><p><code>lower_variable_bounds::Vector{Float64}</code>: Lower bounds of variable box.</p></li><li><p><code>upper_variable_bounds::Vector{Float64}</code>: Upper bounds of variable box.</p></li><li><p><code>is_integer::BitVector</code>: Is dimension integer valued</p></li><li><p><code>continuous::Bool</code>: Are all dimensions continuous (or fixed)</p></li><li><p><code>lower_bound::Float64</code>: Lower bound of problem solution on nodeBB</p></li><li><p><code>upper_bound::Float64</code>: Upper bound of problem solution on nodeBB</p></li><li><p><code>depth::Int64</code>: Depth of node in B&amp;B tree.</p></li><li><p><code>cont_depth::Int64</code>: Depth of first parent in B&amp;B tree that was continuously valued</p></li><li><p><code>id::Int64</code>: Unique ID for each node.</p></li><li><p><code>branch_direction::EAGO.BranchDirection</code>: Whether last branch was negative or positive in direction</p></li><li><p><code>last_branch::Int64</code>: Dimension of last branch</p></li><li><p><code>branch_extent::Float64</code>: Extent of last branch (using for psuedocost calculation)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/types/node_bb.jl#L21-L27">source</a></section></article><p>The global optimizer structure holds all information relevant to branch-and-bound.</p><article class="docstring"><header><a class="docstring-binding" id="EAGO.GlobalOptimizer" href="#EAGO.GlobalOptimizer"><code>EAGO.GlobalOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct GlobalOptimizer{Q, S, T&lt;:ExtensionType} &lt;: MathOptInterface.AbstractOptimizer</code></pre><p>Optimizer internal to EAGO which holds information used to perform branch-and-bound in order to solve nonconvex MINLPs.</p><p>Descriptions of all fields available in extended help.</p><p><strong>Extended Help</strong></p><ul><li><p><code>_subsolvers::SubSolvers{Q, S, T} where {Q, S, T&lt;:ExtensionType}</code>: Storage for relaxed and upper optimizers to use, and any custom extensions</p></li><li><p><code>_parameters::EAGOParameters</code>: Parameters that do not change during a global solve</p></li><li><p><code>_input_problem::InputProblem</code>: Expressions and constraints added to the EAGO model (not directly     used for relaxations)</p></li><li><p><code>_working_problem::ParsedProblem</code>: Expressions and problem descriptions that EAGO uses to formulate     relaxed problems</p></li><li><p><code>_auxiliary_variable_info::Union{Nothing, EAGO._AuxVarData}</code>: Information on any auxiliary variables</p></li><li><p><code>obbt_variable_values::Vector{Bool}</code>: Variables to perform OBBT on (default: all variables in nonlinear expressions)</p></li><li><p><code>enable_optimize_hook::Bool</code>: Specifies that the optimize_hook! function should be called rather than throw the     problem to the standard routine</p></li><li><p><code>ext::Any</code>: (Deprecated, use _subsolvers instead) Storage for custom extension types</p></li><li><p><code>_end_state::EAGO.GlobalEndState</code>: The completion status code for the branch-and-bound algorithm</p></li><li><p><code>_termination_status_code::MathOptInterface.TerminationStatusCode</code>: The MathOptInterface-compliant completion status code</p></li><li><p><code>_result_status_code::MathOptInterface.ResultStatusCode</code>: Value indicating the feasibility status of the result</p></li><li><p><code>_obj_mult::Float64</code>: Multiplier used internally to convert objective sense from Max to Min. Only     takes on values of {-1.0, 1.0}</p></li><li><p><code>_obj_var_slack_added::Bool</code>: Flag to indicate if a slack variable was added for the objective function. This     is done in some epigraph reformulations (see <a href="optimizer/@ref"><code>reform_epigraph_min!</code></a>)</p></li><li><p><code>_stack::DataStructures.BinaryMinMaxHeap{NodeBB}</code>: A heap of all nodes in the branch-and-bound tree</p></li><li><p><code>_current_node::NodeBB</code>: The individual node being examined at any particular time. Nodes are removed from     the stack and placed here, evaluated, and then sent back to the stack</p></li><li><p><code>_first_relax_point_set::Bool</code>: (Unused) Flag for relaxation points</p></li><li><p><code>_current_xref::Vector{Float64}</code>: (Unused) Variable values of a particular point</p></li><li><p><code>_candidate_xref::Vector{Float64}</code>: (Unused) Variable values of a candidate point</p></li><li><p><code>_use_prior_objective_xref::Bool</code>: (Unused) Flag to use variable values from previous evaluation on the current step</p></li><li><p><code>_current_objective_xref::Vector{Float64}</code>: (Unused) Variable values for objective evaluation</p></li><li><p><code>_prior_objective_xref::Vector{Float64}</code>: (Unused) Variable values for previous objective evaluation</p></li><li><p><code>_user_branch_variables::Bool</code>: Flag for if the user has specified branch variables (see <a href="optimizer/@ref"><code>label_branch_variables!</code></a>)</p></li><li><p><code>_fixed_variable::Vector{Bool}</code>: Variables that are fixed in place</p></li><li><p><code>_branch_variable_count::Int64</code>: Number of variables that can be branched on</p></li><li><p><code>_branch_to_sol_map::Vector{Int64}</code>: Mapping from the branch variables to the full set of variables in the problem</p></li><li><p><code>_sol_to_branch_map::Vector{Int64}</code>: Mapping from the full set of variables in the problem to the branch variables</p></li><li><p><code>_continuous_solution::Vector{Float64}</code>: The final (or intermediate) variable values of the solution</p></li><li><p><code>_preprocess_feasibility::Bool</code>: Flag to ensure preprocessing result is feasible</p></li><li><p><code>_preprocess_termination_status::MathOptInterface.TerminationStatusCode</code>: Status codes for use in bounds tightening</p></li><li><p><code>_preprocess_primal_status::MathOptInterface.ResultStatusCode</code>: Status codes for use in bounds tightening</p></li><li><p><code>_preprocess_dual_status::MathOptInterface.ResultStatusCode</code>: Status codes for use in bounds tightening</p></li><li><p><code>_lower_primal_status::MathOptInterface.ResultStatusCode</code>: Primal status of the lower problem</p></li><li><p><code>_lower_dual_status::MathOptInterface.ResultStatusCode</code>: Dual status of the lower problem</p></li><li><p><code>_lower_termination_status::MathOptInterface.TerminationStatusCode</code>: Termination status of the lower problem</p></li><li><p><code>_lower_feasibility::Bool</code>: Flag for lower problem feasibility</p></li><li><p><code>_lower_objective_value::Float64</code>: Objective value result from the lower problem</p></li><li><p><code>_lower_solution::Vector{Float64}</code>: Variable values of the lower problem solution</p></li><li><p><code>_lower_lvd::Vector{Float64}</code>: Lower variable duals for use in duality-based bound tightening</p></li><li><p><code>_lower_uvd::Vector{Float64}</code>: Upper variable duals for use in duality-based bound tightening</p></li><li><p><code>_last_cut_objective::Float64</code>: Objective value associated with the previous cut in the cutting planes algorithm</p></li><li><p><code>_upper_result_status::MathOptInterface.ResultStatusCode</code>: Primal status of the upper problem</p></li><li><p><code>_upper_termination_status::MathOptInterface.TerminationStatusCode</code>: Termination status of the upper problem</p></li><li><p><code>_upper_feasibility::Bool</code>: Flag for upper problem feasibility</p></li><li><p><code>_upper_objective_value::Float64</code>: Objective value result from the upper problem</p></li><li><p><code>_upper_variables::Vector{MathOptInterface.VariableIndex}</code>: </p></li><li><p><code>_upper_solution::Vector{Float64}</code>: </p></li><li><p><code>_postprocess_feasibility::Bool</code>: (Unused) Flag to ensure postprocessing result is feasible</p></li><li><p><code>_time_left::Float64</code>: Time remaining for the optimization algorithm. This is set in <code>initial_parse!</code> to the user-defined     time limit and is decremented throughout <code>global_solve!</code></p></li><li><p><code>_start_time::Float64</code>: Storage for the <code>time()</code> when optimization began</p></li><li><p><code>_run_time::Float64</code>: Current run time, incremented using <code>time()-_start_time</code></p></li><li><p><code>_parse_time::Float64</code>: A field to keep track of time spent on initial problem parsing</p></li><li><p><code>_presolve_time::Float64</code>: Used in <code>optimize_nonconvex.jl</code> to track how long the presolve step takes</p></li><li><p><code>_last_preprocess_time::Float64</code>: Updated each iteration to track the time of the preprocess step</p></li><li><p><code>_last_lower_problem_time::Float64</code>: Updated each iteration to track the time of the lower problem step</p></li><li><p><code>_last_upper_problem_time::Float64</code>: Updated each iteration to track the time of the upper problem step</p></li><li><p><code>_last_postprocessing_time::Float64</code>: Updated each iteration to track the time of the postprocess step</p></li><li><p><code>_min_converged_value::Float64</code>: A field to track convergence progress across iterations</p></li><li><p><code>_global_lower_bound::Float64</code>: The best-known lower bound</p></li><li><p><code>_global_upper_bound::Float64</code>: The best-known upper bound</p></li><li><p><code>_maximum_node_id::Int64</code>: The total number of nodes that have been created</p></li><li><p><code>_iteration_count::Int64</code>: The number of iterations the branch-and-bound algorithm has completed</p></li><li><p><code>_node_count::Int64</code>: The number of nodes in the stack</p></li><li><p><code>_solution_value::Float64</code>: (Unused) The best-known solution value</p></li><li><p><code>_feasible_solution_found::Bool</code>: A flag for if a feasible solution was identified. Updated if preprocessing,     lower problem, and upper problem all return feasible values</p></li><li><p><code>_solution_node::Int64</code>: The node ID of the best-known feasible upper problem solution (default = -1, if no feasible solution is found)</p></li><li><p><code>_best_upper_value::Float64</code>: The best-known upper bound</p></li><li><p><code>_obbt_working_lower_index::Vector{Bool}</code>: Indices of variables to perform OBBT on</p></li><li><p><code>_obbt_working_upper_index::Vector{Bool}</code>: Indices of variables to perform OBBT on</p></li><li><p><code>_lower_indx_diff::Vector{Bool}</code>: Tracker for changes in <em>obbt</em>working<em>lower</em>index across iterations</p></li><li><p><code>_upper_indx_diff::Vector{Bool}</code>: Tracker for changes in <em>obbt</em>working<em>upper</em>index across iterations</p></li><li><p><code>_old_low_index::Vector{Bool}</code>: Storage for indices prior to OBBT step</p></li><li><p><code>_old_upp_index::Vector{Bool}</code>: Storage for indices prior to OBBT step</p></li><li><p><code>_new_low_index::Vector{Bool}</code>: New indices following OBBT step; compared with <code>_old_low_index</code></p></li><li><p><code>_new_upp_index::Vector{Bool}</code>: New indices following OBBT step; compared with <code>_old_upp_index</code></p></li><li><p><code>_obbt_variables::Vector{MathOptInterface.VariableIndex}</code>: (Deprecated) Variables to perform OBBT on. Replaced by <code>_obbt_working_lower_index</code> and <code>_obbt_working_upper_index</code></p></li><li><p><code>_obbt_variable_count::Int64</code>: The number of variables to perform OBBT on</p></li><li><p><code>_obbt_performed_flag::Bool</code>: (Unused) Flag to indicate whether OBBT has been performed</p></li><li><p><code>_lower_fbbt_buffer::Vector{Float64}</code>: Buffer for FBBT lower bounds. Set in presolve, used in preprocess</p></li><li><p><code>_upper_fbbt_buffer::Vector{Float64}</code>: Buffer for FBBT upper bounds. Set in presolve, used in preprocess</p></li><li><p><code>_cp_improvement::Float64</code>: (Unused) Improvement in constraint propagation</p></li><li><p><code>_cp_evaluation_reverse::Bool</code>: (Unused) Flag for if constraint propagation results need to be reversed</p></li><li><p><code>_cut_iterations::Int64</code>: Iterations of the cutting planes algorithm completed</p></li><li><p><code>_cut_add_flag::Bool</code>: (Unused) Flag to check if cuts should be added</p></li><li><p><code>_node_repetitions::Int64</code>: Counter for number of times a node is evaluated. If the <code>repeat_check</code> function     is overloaded to return <code>true</code>, a node will not be branched on, but will instead     be added back into the stack using <code>single_storage!</code>. In this case, <code>_node_repetitions</code>     is incremented</p></li><li><p><code>_log::Log</code>: Storage for logging information during a branch-and-bound run</p></li><li><p><code>_affine_relax_ci::Vector{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}}</code>: Storage for affine constraints</p></li><li><p><code>_affine_objective_cut_ci::Union{Nothing, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.LessThan{Float64}}}</code>: Storage for a linear objective cut constraint</p></li><li><p><code>_relaxed_variable_number::Int64</code>: (Unused) Number of relaxed variables</p></li><li><p><code>_relaxed_variable_index::Vector{MathOptInterface.VariableIndex}</code>: Indices of relaxed variables</p></li><li><p><code>_relaxed_variable_et::Vector{Tuple{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.EqualTo{Float64}}, Int64}}</code>: Stored EqualTo constraints</p></li><li><p><code>_relaxed_variable_lt::Vector{Tuple{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.LessThan{Float64}}, Int64}}</code>: Stored LessThan constraints</p></li><li><p><code>_relaxed_variable_gt::Vector{Tuple{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}, Int64}}</code>: Stored GreaterThan constraints</p></li><li><p><code>_relaxed_variable_integer::Vector{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}}</code>: Stored Integer constraints</p></li><li><p><code>_branch_variables::Vector{Bool}</code>: List of variables that can be branched on. If not user-specified, branch variables     are identified in <code>label_branch_variables!</code></p></li><li><p><code>_nonbranching_int::Bool</code>: (Unused) Flag for non-branching integers</p></li><li><p><code>_new_eval_constraint::Bool</code>: Flag indicating if an initial evaluation of the constraints has occurred</p></li><li><p><code>_new_eval_objective::Bool</code>: Flag indicating if the objective expression was evaluated</p></li><li><p><code>_node_to_sv_leq_ci::Dict{Int64, MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.LessThan{Float64}}}</code>: Storage for carrying LessThan constraint information. Used in <code>obbt!</code> and     <code>update_relaxed_problem_box!</code></p></li><li><p><code>_node_to_sv_geq_ci::Dict{Int64, MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}}</code>: Storage for carrying GreaterThan constraint information. Used in <code>obbt!</code> and     <code>update_relaxed_problem_box!</code></p></li><li><p><code>_nonlinear_evaluator_created::Bool</code>: Flag to check for nonlinear evaluators. Set to <code>true</code> in <code>add_nonlinear_evaluator!</code></p></li><li><p><code>_branch_cost::EAGO.BranchCostStorage{Float64}</code>: (FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED) Storage for pseudocost branching</p></li><li><p><code>_branch_variable_sparsity::SparseArrays.SparseMatrixCSC{Bool, Int64}</code>: (FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED) Sparsity information of the     branch variables</p></li><li><p><code>_constraint_infeasiblity::Vector{Float64}</code>: (FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED) Information on the infeasibility     of each constraint</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/types/global_optimizer.jl#L561-L571">source</a></section></article><h1 id="Customizable-Subroutines"><a class="docs-heading-anchor" href="#Customizable-Subroutines">Customizable Subroutines</a><a id="Customizable-Subroutines-1"></a><a class="docs-heading-anchor-permalink" href="#Customizable-Subroutines" title="Permalink"></a></h1><h2 id="Stack-Management-Subroutines"><a class="docs-heading-anchor" href="#Stack-Management-Subroutines">Stack Management Subroutines</a><a id="Stack-Management-Subroutines-1"></a><a class="docs-heading-anchor-permalink" href="#Stack-Management-Subroutines" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.branch_node!-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.branch_node!-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.branch_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">branch_node!(t::ExtensionType, m::GlobalOptimizer)
</code></pre><p>Create two nodes from <code>current_node</code> and store them on the stack. Call <code>select_branch_variable(t, m)</code> and <code>select_branch_point(t, m, k)</code> to determine the variable that should be branched on and the point at which branching should occur, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/stack_management.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.select_branch_variable-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.select_branch_variable-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.select_branch_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_branch_variable(
    t::ExtensionType,
    m::GlobalOptimizer
) -&gt; Any
</code></pre><p>Choose a variable to branch on. A maximum relative width branching rule is used by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/stack_management.jl#L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.select_branch_point-Tuple{ExtensionType, GlobalOptimizer, Any}" href="#EAGO.select_branch_point-Tuple{ExtensionType, GlobalOptimizer, Any}"><code>EAGO.select_branch_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_branch_point(
    t::ExtensionType,
    m::GlobalOptimizer,
    i
) -&gt; Float64
</code></pre><p>Select a point <code>xb</code> within the domain of the <code>i</code>th branching variable. By default, this point is a convex combination of the solution to the relaxation and the midpoint of the node (<code>branch_cvx_factor*xmid + (1-branch_cvx_factor)*xsol</code>). If the solution lies within <code>branch_offset</code> of a bound, then the branch point is moved to a distance of <code>branch_offset</code> from that bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/stack_management.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.node_selection!-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.node_selection!-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.node_selection!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">node_selection!(t::ExtensionType, m::GlobalOptimizer)
</code></pre><p>Select the next node in the stack to evaluate. By default, perform best-first  node selection (select the node with the lowest lower bound in the stack).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/stack_management.jl#L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.fathom!-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.fathom!-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.fathom!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fathom!(t::ExtensionType, m::GlobalOptimizer)
</code></pre><p>Remove nodes from the stack. By default, delete nodes from the stack if their lower bounds are greater than the current global upper bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/stack_management.jl#L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.initialize_stack!-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.initialize_stack!-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.initialize_stack!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_stack!(t::ExtensionType, m::GlobalOptimizer)
</code></pre><p>Prepare the stack for the branch-and-bound routine. By default, create an initial node with the variable bounds as box constraints and add it to the stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/stack_management.jl#L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.single_storage!-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.single_storage!-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.single_storage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">single_storage!(t::ExtensionType, m::GlobalOptimizer)
</code></pre><p>Store the current node to the stack, without branching, after updating lower/upper bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/stack_management.jl#L181">source</a></section></article><h2 id="Internal-Subproblem-Status-Codes-and-Subsolver-Management"><a class="docs-heading-anchor" href="#Internal-Subproblem-Status-Codes-and-Subsolver-Management">Internal Subproblem Status Codes and Subsolver Management</a><a id="Internal-Subproblem-Status-Codes-and-Subsolver-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Subproblem-Status-Codes-and-Subsolver-Management" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.RelaxResultStatus" href="#EAGO.RelaxResultStatus"><code>EAGO.RelaxResultStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelaxResultStatus</code></pre><p>Status code used internally to determine how to interpret the results from the solution of a relaxed problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/lower_problem.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.LocalResultStatus" href="#EAGO.LocalResultStatus"><code>EAGO.LocalResultStatus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalResultStatus</code></pre><p>Status code used internally to determine how to interpret the results from the solution of a local problem solve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/optimize_convex.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.Incremental" href="#EAGO.Incremental"><code>EAGO.Incremental</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Incremental{S&lt;:MathOptInterface.AbstractOptimizer} &lt;: MathOptInterface.AbstractOptimizer</code></pre><p>A type-stable cache used to wrapper for an optimizer that enables incremental modification of solvers that don&#39;t inherently suppport this. Explicitly checks support of MOI functionality used in EAGO. </p><p>(Deprecated) For <code>Q = Val{true}</code>, the subsolver supports incremental loading.  For <code>Q = Val{false}</code>, the subsolver does not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/types/incremental.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.SubSolvers" href="#EAGO.SubSolvers"><code>EAGO.SubSolvers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SubSolvers{Q&lt;:MathOptInterface.AbstractOptimizer, S&lt;:MathOptInterface.AbstractOptimizer, T&lt;:ExtensionType}</code></pre><p>A structure containing the relaxed and upper optimizers to be used, as well as any user-defined extension.</p><ul><li><p><code>relaxed_optimizer::MathOptInterface.AbstractOptimizer</code>: Optimizer used to solve relaxed subproblems. Set using <code>r = [...]</code> (&lt;: <code>MOI.AbstractOptimizer</code>)         (default = <code>Cbc.Optimizer()</code>)</p></li><li><p><code>upper_optimizer::MathOptInterface.AbstractOptimizer</code>: Optimizer used to solve upper bounding problems. Set using <code>u = [...]</code> (&lt;: <code>MOI.AbstractOptimizer</code>)         (default = <code>Ipopt.Optimizer()</code>)</p></li><li><p><code>ext::ExtensionType</code>: User-defined extension to use. Set using <code>t = [...]</code>(&lt;: <code>EAGO.ExtensionType</code>)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/types/subsolver_block.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.set_default_config!-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.set_default_config!-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.set_default_config!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_default_config!</code></pre><p>Configures subsolver tolerances based on tolerance parameters provided to EAGO (provided that a specialized subsolver configuration routine has been provided and <code>m.user_solver_config = false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/configure_subsolver.jl#L45-L51">source</a></section></article><h2 id="Main-Subproblem-and-Termination-Subroutines"><a class="docs-heading-anchor" href="#Main-Subproblem-and-Termination-Subroutines">Main Subproblem and Termination Subroutines</a><a id="Main-Subproblem-and-Termination-Subroutines-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Subproblem-and-Termination-Subroutines" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.convergence_check-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.convergence_check-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.convergence_check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convergence_check(
    t::ExtensionType,
    m::GlobalOptimizer
) -&gt; Bool
</code></pre><p>Check for problem convergence.</p><p>By default, check if the lower and upper bounds have converged to within absolute and/or relative tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/optimize_nonconvex.jl#L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.cut_condition-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.cut_condition-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.cut_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cut_condition(t::ExtensionType, m::GlobalOptimizer) -&gt; Bool
</code></pre><p>Returns <code>true</code> if a cut should be added and computes a new reference point to add the cut at. By default, checks that <code>cut_max_iterations</code> are not exceeded and that the  improvement in the objective value associated with the previous cut is greater than both an absolute tolerance <code>cut_ϵ_abs</code> and a relative tolerance <code>cut_ϵ_rel</code>. Returns <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/lower_problem.jl#L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.lower_problem!-Union{Tuple{Q}, Tuple{S}, Tuple{R}, Tuple{ExtensionType, GlobalOptimizer{R, S, Q}}} where {R, S, Q&lt;:ExtensionType}" href="#EAGO.lower_problem!-Union{Tuple{Q}, Tuple{S}, Tuple{R}, Tuple{ExtensionType, GlobalOptimizer{R, S, Q}}} where {R, S, Q&lt;:ExtensionType}"><code>EAGO.lower_problem!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lower_problem!(
    t::ExtensionType,
    m::GlobalOptimizer{R, S, Q&lt;:ExtensionType}
)
</code></pre><p>Constructs a relaxation of the MINLP on node <code>y</code> and solves it using the default EAGO  relaxation scheme. By default, EAGO applies Kelley&#39;s algorithm (from Kelley Jr., J.E.:  The cutting-plane method for solving convex programs. J. Soc. Ind. Appl. Math. 8(4),  703 to 712 (1960)) while <code>cut_condition(m)</code> returns <code>true</code> then activates the integrality constraints of the relaxed problems and solves the resulting MILP relaxation. results are stored to the <code>_lower_solution</code>, <code>_lower_termination_status</code>, <code>_lower_primal_status</code>, <code>_lower_dual_status</code>, <code>_lower_objective_value</code>, and <code>_lower_feasibility</code>. Further, lower and upper variable duals are stored <code>_lower_lvd</code> and <code>_lower_uvd</code>, respectively, for use in duality based bound tightening. If relaxation-based bounds are weaker or cutting-planes  are numerically poorly ill-posed, then interval bounds are used instead. If the problem is dual feasible but the primal status is ambiguous the dual objective value is used for the  lower bound to avoid numerical issues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/lower_problem.jl#L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.preprocess!-Union{Tuple{Q}, Tuple{S}, Tuple{R}, Tuple{ExtensionType, GlobalOptimizer{R, S, Q}}} where {R, S, Q&lt;:ExtensionType}" href="#EAGO.preprocess!-Union{Tuple{Q}, Tuple{S}, Tuple{R}, Tuple{ExtensionType, GlobalOptimizer{R, S, Q}}} where {R, S, Q&lt;:ExtensionType}"><code>EAGO.preprocess!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preprocess!(
    t::ExtensionType,
    m::GlobalOptimizer{R, S, Q&lt;:ExtensionType}
)
</code></pre><p>Runs contractor methods prior to solving lower bounding problem. By default linear and quadratic  contractor methods followed by interval constraint propagation then optimization-based bound  tightening for a specified number of iterations while the subproblem at current node <code>n</code> has  not been proven infeasible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/lower_problem.jl#L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.postprocess!-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.postprocess!-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.postprocess!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">postprocess!(t::ExtensionType, m::GlobalOptimizer)
</code></pre><p>Default postprocess perfoms duality-based bound tightening (Tawarmalani, M.,  Sahinidis, N.V.: Global optimization of mixed-integer nonlinear programs:  a theoretical and computational study. Math. Progr. 99, 563–591 (2004).) up to an iteration limit set by <code>dbbt_depth</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/postprocess.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.repeat_check-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.repeat_check-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.repeat_check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat_check(t::ExtensionType, m::GlobalOptimizer) -&gt; Bool
</code></pre><p>Check to see if current node should be reprocessed. Without any custom extension, return <code>false</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/postprocess.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.termination_check-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.termination_check-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.termination_check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">termination_check(m::GlobalOptimizer)
termination_check(t::ExtensionType, m::GlobalOptimizer) -&gt; Bool</code></pre><p>Check for termination of the branch-and-bound algorithm.</p><p>If only the <code>GlobalOptimizer</code> is given as an argument, <code>termination_check</code> dispatches to the other form using the <code>ExtensionType</code> given in the <code>SubSolvers</code>. If there is no user-defined extension, then by default, this will check for satisfaction of absolute or relative tolerances, solution infeasibility, and other specified limits. Returns  <code>true</code> if any conditions are met and branch-and-bound should end, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/optimize_nonconvex.jl#L159-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.upper_problem!-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.upper_problem!-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.upper_problem!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">upper_problem!(t::ExtensionType, m::GlobalOptimizer)
</code></pre><p>Default upper bounding problem which simply calls <code>solve_local_nlp!</code> to solve the NLP locally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/upper_problem.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.parse_global!-Tuple{ExtensionType, GlobalOptimizer}" href="#EAGO.parse_global!-Tuple{ExtensionType, GlobalOptimizer}"><code>EAGO.parse_global!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Basic parsing for global solutions (no extensive manipulation). By default, does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/optimize_nonconvex.jl#L22-L25">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>EAGO.optimize_hook!(t::ExtensionType, m::GlobalOptimizer)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Internal-Subroutines"><a class="docs-heading-anchor" href="#Internal-Subroutines">Internal Subroutines</a><a id="Internal-Subroutines-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Subroutines" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.is_integer_subproblem-Tuple{Any}" href="#EAGO.is_integer_subproblem-Tuple{Any}"><code>EAGO.is_integer_subproblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_integer_subproblem(m)
</code></pre><p>Returns <code>true</code> that the subproblem at the current node <code>n</code> has participating integer variables that have not been fixed to constant valued as the branch-and-bound algorithm progresses. Returns <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/lower_problem.jl#L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.is_integer_feasible_local-Tuple{GlobalOptimizer, Any}" href="#EAGO.is_integer_feasible_local-Tuple{GlobalOptimizer, Any}"><code>EAGO.is_integer_feasible_local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_integer_feasible_local(m::GlobalOptimizer, d) -&gt; Bool
</code></pre><p>Checks that the solution of a local solve is integer feasible to within the tolerances specified by <code>integer_abs_tol</code> and <code>integer_rel_tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/optimize_convex.jl#L16">source</a></section></article><h2 id="Functions-for-Generating-Console-Output"><a class="docs-heading-anchor" href="#Functions-for-Generating-Console-Output">Functions for Generating Console Output</a><a id="Functions-for-Generating-Console-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-for-Generating-Console-Output" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.print_iteration!" href="#EAGO.print_iteration!"><code>EAGO.print_iteration!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>print_iteration!</p><p>Print status information based on iteration count. The header print frequency is based on the <code>header_iterations</code> setting, and the data print frequency is based on the <code>output_iterations</code> setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/display.jl#L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.print_node!" href="#EAGO.print_node!"><code>EAGO.print_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>print_node!</p><p>Print information about the current node. Includes node ID, lower bound, upper bound, and interval box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/display.jl#L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.print_results!" href="#EAGO.print_results!"><code>EAGO.print_results!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_results!(m::GlobalOptimizer, lower_flag::Bool)
</code></pre><p>Print the results of a single (lower or upper) bounding problem. <code>lower_flag=true</code> prints information for the lower problem, <code>lower_flag=false</code> prints information for the upper problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/display.jl#L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.print_solution!" href="#EAGO.print_solution!"><code>EAGO.print_solution!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>print_solution!</p><p>Print solution information for the B&amp;B problem. Display node with the best solution, solution value, solution, and time spent solving subproblems. This print occurs following termination of the B&amp;B algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/display.jl#L15">source</a></section></article><h2 id="Support-for-Log-Output-at-Each-Iteration"><a class="docs-heading-anchor" href="#Support-for-Log-Output-at-Each-Iteration">Support for Log Output at Each Iteration</a><a id="Support-for-Log-Output-at-Each-Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Support-for-Log-Output-at-Each-Iteration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.Log" href="#EAGO.Log"><code>EAGO.Log</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Log</code></pre><p>A structure used to store information on the history of the solution procedure for generating convergence plots and other analyses.</p><ul><li><p><code>current_lower_bound::Vector{Float64}</code>: Storage for lower bound calculated for current node.</p></li><li><p><code>current_upper_bound::Vector{Float64}</code>: Storage for upper bound calculated for current node.</p></li><li><p><code>preprocessing_time::Vector{Float64}</code>: Storage for preprocessing time of each iteration.</p></li><li><p><code>lower_problem_time::Vector{Float64}</code>: Storage for lower bounding time of each iteration.</p></li><li><p><code>upper_problem_time::Vector{Float64}</code>: Storage for upper bounding time of each iteration.</p></li><li><p><code>postprocessing_time::Vector{Float64}</code>: Storage for postprocessing time of each iteration.</p></li><li><p><code>preprocessing_feas::Vector{Bool}</code>: Storage for preprocessing feasibility of each iteration.</p></li><li><p><code>lower_problem_feas::Vector{Bool}</code>: Storage for lower bounding feasibility of each iteration.</p></li><li><p><code>upper_problem_feas::Vector{Bool}</code>: Storage for upper bounding feasibility of each iteration.</p></li><li><p><code>postprocessing_feas::Vector{Bool}</code>: Storage for postprocessing feasibility of each iteration.</p></li><li><p><code>global_lower_bound::Vector{Float64}</code>: Storage for best (global) lower bound at each iteration.</p></li><li><p><code>global_upper_bound::Vector{Float64}</code>: Storage for best (global) upper bound at each iteration.</p></li><li><p><code>node_count::Vector{Int64}</code>: Number of nodes at each iteration.</p></li><li><p><code>run_time::Vector{Float64}</code>: Run time at each iteration.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/types/log.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.log_iteration!-Tuple{GlobalOptimizer}" href="#EAGO.log_iteration!-Tuple{GlobalOptimizer}"><code>EAGO.log_iteration!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_iteration!(m::GlobalOptimizer)
</code></pre><p>If <code>log_on</code> is true, the <code>global_lower_bound</code>, <code>global_upper_bound</code>, <code>run_time</code>, and <code>node_count</code> are stored every <code>log_interval</code>. If <code>log_subproblem_info</code> then the lower bound, feasibility and run times of the subproblems are logged every <code>log_interval</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/optimize/nonconvex/log_iteration.jl#L13">source</a></section></article><h2 id="Interval-Representations-of-Expressions"><a class="docs-heading-anchor" href="#Interval-Representations-of-Expressions">Interval Representations of Expressions</a><a id="Interval-Representations-of-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Interval-Representations-of-Expressions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.AbstractEAGOConstraint" href="#EAGO.AbstractEAGOConstraint"><code>EAGO.AbstractEAGOConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractEAGOConstraint</code></pre><p>An abstract super-type used for representing constraints built by EAGO&#39;s backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/functions/functions.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.AffineFunctionEq" href="#EAGO.AffineFunctionEq"><code>EAGO.AffineFunctionEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AffineFunctionEq &lt;: EAGO.AbstractEAGOConstraint</code></pre><p>Representation of an affine equality. Currently only used for bound tightening.</p><ul><li><p><code>terms::Vector{Tuple{Float64, Int64}}</code></p></li><li><p><code>constant::Float64</code></p></li><li><p><code>len::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/functions/functions.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.AffineFunctionIneq" href="#EAGO.AffineFunctionIneq"><code>EAGO.AffineFunctionIneq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AffineFunctionIneq &lt;: EAGO.AbstractEAGOConstraint</code></pre><p>Representation of an affine inequality. Currently only used for bound tightening.</p><ul><li><p><code>terms::Vector{Tuple{Float64, Int64}}</code></p></li><li><p><code>constant::Float64</code></p></li><li><p><code>len::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/functions/functions.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.BufferedQuadraticIneq" href="#EAGO.BufferedQuadraticIneq"><code>EAGO.BufferedQuadraticIneq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct BufferedQuadraticIneq &lt;: EAGO.AbstractEAGOConstraint</code></pre><p>Representation of a general quadratic inequality constraint with a buffer.</p><ul><li><p><code>func::MathOptInterface.ScalarQuadraticFunction{Float64}</code></p></li><li><p><code>buffer::Dict{Int64, Float64}</code></p></li><li><p><code>saf::MathOptInterface.ScalarAffineFunction{Float64}</code></p></li><li><p><code>len::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/functions/functions.jl#L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.BufferedQuadraticEq" href="#EAGO.BufferedQuadraticEq"><code>EAGO.BufferedQuadraticEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct BufferedQuadraticEq &lt;: EAGO.AbstractEAGOConstraint</code></pre><p>Representation of a general quadratic equality constraint with a buffer.</p><ul><li><p><code>func::MathOptInterface.ScalarQuadraticFunction{Float64}</code></p></li><li><p><code>minus_func::MathOptInterface.ScalarQuadraticFunction{Float64}</code></p></li><li><p><code>buffer::Dict{Int64, Float64}</code></p></li><li><p><code>saf::MathOptInterface.ScalarAffineFunction{Float64}</code></p></li><li><p><code>len::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/functions/functions.jl#L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.NonlinearExpression" href="#EAGO.NonlinearExpression"><code>EAGO.NonlinearExpression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct NonlinearExpression{V, N, T&lt;:RelaxTag} &lt;: EAGO.AbstractEAGOConstraint</code></pre><p>Stores a general quadratic function with a buffer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/functions/nonlinear/nonlinear.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.BufferedNonlinearFunction" href="#EAGO.BufferedNonlinearFunction"><code>EAGO.BufferedNonlinearFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct BufferedNonlinearFunction{V, N, T&lt;:RelaxTag} &lt;: EAGO.AbstractEAGOConstraint</code></pre><p>Stores a general nonlinear function with a buffer represented by the sum of a tape and a scalar affine function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/005484d83e9eb70f29d189e66752768d97490e4d/src/eago_optimizer/functions/nonlinear/nonlinear.jl#L86">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimizer/">« EAGO Optimizer</a><a class="docs-footer-nextpage" href="../relax_back/">Nonlinear Backend »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 30 June 2023 22:12">Friday 30 June 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
