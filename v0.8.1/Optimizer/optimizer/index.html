<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>EAGO Optimizer · EAGO.jl: Easy Advanced Global Optimization</title><link rel="canonical" href="https://PSORLab.github.io/EAGO.jl/stable/Optimizer/optimizer/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">EAGO.jl: Easy Advanced Global Optimization</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Quick Start</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Quick_Start/qs_landing/">Quick Start</a></li><li><a class="tocitem" href="../../Quick_Start/guidelines/">Customization Guidelines</a></li><li><a class="tocitem" href="../../Quick_Start/starting/">Simple Example</a></li><li><a class="tocitem" href="../../Quick_Start/medium/">Simple Example</a></li><li><a class="tocitem" href="../../Quick_Start/custom/">Simple Example</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">McCormick Operator Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../McCormick/overview/">Overview</a></li><li><a class="tocitem" href="../../McCormick/usage/">Basic Usage</a></li><li><a class="tocitem" href="../../McCormick/operators/">Currently supported operators</a></li><li><a class="tocitem" href="../../McCormick/type/">Types</a></li><li><a class="tocitem" href="../../McCormick/implicit/">Relaxation of Implicit Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Global Optimizer</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>EAGO Optimizer</a><ul class="internal"><li><a class="tocitem" href="#EAGO.Optimizer"><span>EAGO.Optimizer</span></a></li><li><a class="tocitem" href="#EAGO-Specific-functions-and-operators"><span>EAGO Specific functions and operators</span></a></li><li><a class="tocitem" href="#Storage-for-Input-Parameters"><span>Storage for Input Parameters</span></a></li><li><a class="tocitem" href="#Internal-Storage-Structures"><span>Internal Storage Structures</span></a></li><li><a class="tocitem" href="#Internal-Problem-Representations"><span>Internal Problem Representations</span></a></li><li><a class="tocitem" href="#Interval-Optimizer-Subroutines"><span>Interval Optimizer Subroutines</span></a></li><li><a class="tocitem" href="#Extending-EAGO"><span>Extending EAGO</span></a></li></ul></li><li><a class="tocitem" href="../bnb_back/">EAGO&#39;s Branch and Bound Routine</a></li><li><a class="tocitem" href="../relax_back/">Nonlinear Backend</a></li><li><a class="tocitem" href="../domain_reduction/">Domain Reduction</a></li><li><a class="tocitem" href="../high_performance/">High-Performance Configuration</a></li><li><a class="tocitem" href="../udf_utilities/">User-Define Functions and DAG Utilities</a></li></ul></li><li><a class="tocitem" href="../../SemiInfinite/semiinfinite/">Semi-Infinite Programming</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Contributing to EAGO</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Dev/contributing/">How to Contribute</a></li><li><a class="tocitem" href="../../Dev/future/">Future Work</a></li></ul></li><li><a class="tocitem" href="../../ref/">References</a></li><li><a class="tocitem" href="../../cite/">Citing EAGO</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Global Optimizer</a></li><li class="is-active"><a href>EAGO Optimizer</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>EAGO Optimizer</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PSORLab/EAGO.jl/blob/master/docs/src/Optimizer/optimizer.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="EAGO-Optimizer"><a class="docs-heading-anchor" href="#EAGO-Optimizer">EAGO Optimizer</a><a id="EAGO-Optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#EAGO-Optimizer" title="Permalink"></a></h1><p>The <code>EAGO.Optimizer</code> object holds all algorithm solution information. A description of all user-facing options has been provided in the docstring.</p><h2 id="EAGO.Optimizer"><a class="docs-heading-anchor" href="#EAGO.Optimizer">EAGO.Optimizer</a><a id="EAGO.Optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#EAGO.Optimizer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.Optimizer" href="#EAGO.Optimizer"><code>EAGO.Optimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Optimizer{Q, S, T} &lt;: MathOptInterface.AbstractOptimizer</code></pre><p>The highest level optimizer object used by EAGO to solve problems during the optimization routine. Additional options and temporary storage are located in the <code>_global_optimizer::GlobalOptimizer{Q,S,T}</code> field. Parameters which are expected to be constant over the entire solve are stored in the <code>_parameters::EAGOParameters</code> field.  Some user-facing keywords not in the <code>EAGOParameters</code> field include:</p><ul><li><code>relaxed_optimizer::MOI.AbstractOptimizer</code>: An instance of the optimizer used to solve    the relaxed subproblems (default = <code>Cbc.Optimizer()</code>). Located in <code>subsolver_block::SubSolvers{Q,S,T}</code>.</li><li><code>upper_optimizer::MOI.AbstractOptimizer</code>: Optimizer used to solve upper bounding problems    (default = <code>Ipopt.Optimizer()</code>). Located in <code>subsolver_block::SubSolvers{Q,S,T}</code>.</li><li><code>ext::ExtensionType</code>: Holds an instance of a subtype of <code>EAGO.ExtensionType</code>, used to define   new custom subroutines (default = <code>DefaultExt()</code>). Located in <code>subsolver_block::SubSolvers{Q,S,T}</code>.</li><li><code>enable_optimize_hook::Bool</code>: Specifies that the user-defined <code>optimize_hook!</code> function should   be called rather than use the standard EAGO optimization routines. Located in <code>Optimizer</code>   and <code>_global_optimizer::GlobalOptimizer{Q,S,T}</code>.</li><li><code>obbt_variable_values::Vector{Bool}</code>: Variables to perform OBBT on (default: all variables in nonlinear   expressions). Located in <code>_global_optimizer::GlobalOptimizer{Q,S,T}</code>.</li></ul><p>Descriptions of all <code>Optimizer</code> fields available in extended help.</p><p><strong>Extended Help</strong></p><ul><li><p><code>subsolver_block::SubSolvers{Q, S, T} where {Q, S, T}</code></p><p>Holds definitions of the relaxed and upper optimizers, as well as any user-defined extension types</p></li><li><p><code>enable_optimize_hook::Bool</code></p><p>Specifies that the optimize_hook! function should be called rather than throw the     problem to the standard routine</p></li><li><p><code>ext::Union{Nothing, T} where T</code></p><p>(Deprecated, use <code>subsolver_block</code> instead) Storage for custom extension types</p></li><li><p><code>_auxiliary_variable_info::Union{Nothing, EAGO._AuxVarData}</code></p><p>Information on any auxiliary variables</p></li><li><p><code>_global_optimizer::GlobalOptimizer{Q, S, T} where {Q, S, T}</code></p><p>Additional options and temporary storage for solving optimization problems</p></li><li><p><code>_input_problem::InputProblem</code></p><p>Expressions and constraints added to the EAGO model (not directly     used for relaxations)</p></li><li><p><code>_working_problem::ParsedProblem</code></p><p>Expressions and problem descriptions that EAGO uses to formulate     relaxed problems</p></li><li><p><code>_parameters::EAGOParameters</code></p><p>Parameters that do not change during a global solve</p></li><li><p><code>_optimizer_attributes_set::Vector{MathOptInterface.AbstractOptimizerAttribute}</code></p><p>Set of optimizer attributes</p></li><li><p><code>_termination_status_code::MathOptInterface.TerminationStatusCode</code></p><p>The MathOptInterface-compliant completion status code</p></li><li><p><code>_result_status_code::MathOptInterface.ResultStatusCode</code></p><p>Value indicating the feasibility status of the result</p></li><li><p><code>_run_time::Float64</code></p><p>Optimization run time</p></li><li><p><code>_objective_value::Float64</code></p><p>The objective value of the primal solution</p></li><li><p><code>_objective_bound::Float64</code></p><p>The best-known bound on the optimal objective value</p></li><li><p><code>_relative_gap::Float64</code></p><p>The gap between the upper and lower bound, relative to the bound with the larger magnitude</p></li><li><p><code>_iteration_count::Int64</code></p><p>The number of iterations the branch-and-bound algorithm has completed</p></li><li><p><code>_node_count::Int64</code></p><p>The number of nodes in the stack</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/839e0fb9aafff3a935906164b6e11641f86bbf73/src/eago_optimizer/optimizer.jl#L14">source</a></section></article><h2 id="EAGO-Specific-functions-and-operators"><a class="docs-heading-anchor" href="#EAGO-Specific-functions-and-operators">EAGO Specific functions and operators</a><a id="EAGO-Specific-functions-and-operators-1"></a><a class="docs-heading-anchor-permalink" href="#EAGO-Specific-functions-and-operators" title="Permalink"></a></h2><p>EAGO supports a number of functions and operators that for which specialized relaxation routines are available. These can be registered and added to a JuMP model using the  function </p><article class="docstring"><header><a class="docstring-binding" id="EAGO.register_eago_operators!-Tuple{Model}" href="#EAGO.register_eago_operators!-Tuple{Model}"><code>EAGO.register_eago_operators!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>register<em>eago</em>operators!</p><p>Registers all nonstandard nonlinear terms available in EAGO in a JuMP. Uses of these is generally preferable in EAGO as the relaxations EAGO will generate will usually be tighter (speeding up convergence time). Note that this will work can be used by other nonlinear solvers (Ipopt for instance).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/839e0fb9aafff3a935906164b6e11641f86bbf73/src/eago_optimizer/functions/nonlinear/register_special.jl#L11-L18">source</a></section></article><h2 id="Storage-for-Input-Parameters"><a class="docs-heading-anchor" href="#Storage-for-Input-Parameters">Storage for Input Parameters</a><a id="Storage-for-Input-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Storage-for-Input-Parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.EAGOParameters" href="#EAGO.EAGOParameters"><code>EAGO.EAGOParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct EAGOParameters</code></pre><p>Storage for parameters that do not change during a global solve.</p><ul><li><p><code>presolve_scrubber_flag::Bool</code></p><p>Should EAGO attempt to remove type-assert issues for user-defined functions (default = false)</p></li><li><p><code>presolve_to_JuMP_flag::Bool</code></p><p>Create and use DAG representations of user-defined functions (default = false)</p></li><li><p><code>presolve_flatten_flag::Bool</code></p><p>Rerrange the DAG using registered transformations (default = false)</p></li><li><p><code>conic_convert_quadratic::Bool</code></p><p>Attempt to bridge convex constraint to second-order cone (default = false)</p></li><li><p><code>log_on::Bool</code></p><p>Turn logging on; record global bounds, node count, and run time. Additional      options are available for recording information specific to subproblems (default = false)</p></li><li><p><code>log_subproblem_info::Bool</code></p><p>Turn on logging of times and feasibility of subproblems (default = false)</p></li><li><p><code>log_interval::Int64</code></p><p>Log data every <code>log_interval</code> iterations (default = 1)</p></li><li><p><code>verbosity::Int64</code></p><p>The amount of information that should be printed to console while solving.     Values range from 0 - 4: 0 is silent, 1 shows iteration summary statistics     only, 2-4 show varying degrees of detail about calculations within each     iteration (default = 1)</p></li><li><p><code>output_iterations::Int64</code></p><p>Display summary of iteration to console every <code>output_iterations</code> (default = 1000)</p></li><li><p><code>header_iterations::Int64</code></p><p>Display header for summary to console every <code>output_iterations</code> (default = 100000)</p></li><li><p><code>branch_cvx_factor::Float64</code></p><p>Convex coefficient used to select branch point. Branch point is given by     <code>branch_cvx_factor*xmid + (1-branch_cvx_factor)*xsol</code> (default = 0.25)</p></li><li><p><code>branch_offset::Float64</code></p><p>Minimum distance from bound to have branch point, normalized by width of     dimension to branch on (default = 0.15)</p></li><li><p><code>branch_pseudocost_on::Bool</code></p><p>Indicate that pseudocost branching should be used (default = false)</p></li><li><p><code>branch_variable::Vector{Bool}</code></p><p>Variables to branch on (default is all nonlinear)</p></li><li><p><code>branch_max_repetitions::Int64</code></p><p>[FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Number of times to repeat node     processing prior to branching (default = 4)</p></li><li><p><code>branch_repetition_tol::Float64</code></p><p>[FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Volume ratio tolerance required     to repeat processing the current node (default = 0.9)</p></li><li><p><code>node_limit::Int64</code></p><p>Maximum number of nodes (default = 1E7)</p></li><li><p><code>time_limit::Float64</code></p><p>Maximum CPU time in seconds (default = 3600)</p></li><li><p><code>iteration_limit::Int64</code></p><p>Maximum number of iterations (default 1E9)</p></li><li><p><code>absolute_tolerance::Float64</code></p><p>Absolute tolerance for termination (default = 1E-3)</p></li><li><p><code>relative_tolerance::Float64</code></p><p>Relative tolerance for termination (default = 1E-3)</p></li><li><p><code>absolute_constraint_feas_tolerance::Float64</code></p><p>Absolute constraint feasibility tolerance (default = 1E-8)</p></li><li><p><code>cp_depth::Int64</code></p><p>Depth in B&amp;B tree above which constraint propagation should be disabled (default = 0)</p></li><li><p><code>cp_repetitions::Int64</code></p><p>Number of times to repeat forward-reverse pass routine (default = 0)</p></li><li><p><code>cp_tolerance::Float64</code></p><p>Disable constraint propagation if the ratio of new node volume to beginning node volume exceeds     this number (default = 0.99)</p></li><li><p><code>cp_interval_only::Bool</code></p><p>Use only valid interval bounds during constraint propagation (default = false)</p></li><li><p><code>obbt_depth::Int64</code></p><p>Depth in B&amp;B tree above which OBBT should be disabled (default = 6)</p></li><li><p><code>obbt_repetitions::Int64</code></p><p>Number of repetitions of OBBT to perform in preprocessing (default = 3)</p></li><li><p><code>obbt_aggressive_on::Bool</code></p><p>Turn on aggresive OBBT (default = true)</p></li><li><p><code>obbt_aggressive_max_iteration::Int64</code></p><p>Maximum iteration to perform aggresive OBBT (default = 2)</p></li><li><p><code>obbt_aggressive_min_dimension::Int64</code></p><p>Minimum dimension to perform aggresive OBBT (default = 2)</p></li><li><p><code>obbt_tolerance::Float64</code></p><p>Tolerance to consider bounds equal (default = 1E-10)</p></li><li><p><code>fbbt_lp_depth::Int64</code></p><p>Depth in B&amp;B tree above which linear FBBT should be disabled (default = 1000)</p></li><li><p><code>fbbt_lp_repetitions::Int64</code></p><p>Number of repetitions of linear FBBT to perform in preprocessing (default = 3)</p></li><li><p><code>dbbt_depth::Int64</code></p><p>Depth in B&amp;B tree above which duality-based bound tightening should be disabled (default = 1E10)</p></li><li><p><code>dbbt_tolerance::Float64</code></p><p>New bound is considered equal to the prior bound if within dbbt_tolerance (default = 1E-8)</p></li><li><p><code>relax_tag::RelaxTag</code></p><p>RelaxTag used to specify type of McCormick operator (default = NS())</p></li><li><p><code>subgrad_tighten::Bool</code></p><p>Perform tightening of interval bounds using subgradients at each factor in     each nonlinear tape during a forward pass (default = true)</p></li><li><p><code>reverse_subgrad_tighten::Bool</code></p><p>Perform tightening of interval bounds using subgradients at each factor in     each nonlinear tape during a reverse pass (default = false)</p></li><li><p><code>subgrad_tol::Float64</code></p><p>Outer-round computed subgradient bounds by this amount (default = 1E-10)</p></li><li><p><code>mul_relax_style::Int64</code></p><p>Select the type of relaxation to use for the bilinear term (multiplication): 0 corresponds to      a standard McCormick arithmetic approach. Settings 1-3 augment the standard McCormick relaxation      with implied apriori relaxations: (1) corresponds to a subgradient-based apriori relaxation approach; (2)      corresponds to an affine arithmetic-based apriori approach; and (3) corresponds to a enumerative apriori      relaxation-based approach (default = 0)</p></li><li><p><code>cut_min_iterations::Int64</code></p><p>Minimum number of cuts at each node to attempt (unsafe cuts not necessarily added) (default = 2)</p></li><li><p><code>cut_max_iterations::Int64</code></p><p>Maximum number of cuts at each node to attempt (default = 8)</p></li><li><p><code>cut_tolerance_abs::Float64</code></p><p>Absolute tolerance checked for continuing cut (default = 1E-6)</p></li><li><p><code>cut_tolerance_rel::Float64</code></p><p>Relative tolerance checked for continuing cut (default = 1E-3)</p></li><li><p><code>cut_safe_on::Bool</code></p><p>Use tolerances to determine safe cuts in a Khajavirad 2018 manner (default = true)</p></li><li><p><code>cut_safe_l::Float64</code></p><p>Lower tolerance for safe-lp cut, Khajavirad 2018 (default = 1E-7)</p></li><li><p><code>cut_safe_u::Float64</code></p><p>Upper tolerance for safe-lp cut, Khajavirad 2018 (default = 1E7)</p></li><li><p><code>cut_safe_b::Float64</code></p><p>Constant tolerance for safe-lp cut, Khajavirad 2018 (default = 1E9)</p></li><li><p><code>upper_bounding_depth::Int64</code></p><p>Solve upper problem for every node with depth less than <code>upper_bounding_depth</code>,     and otherwise solve upper problems with a probability of <code>(1/2)^(depth-upper_bounding_depth)</code>     (default = 8)</p></li><li><p><code>domain_violation_guard_on::Bool</code></p><p>(Unused) Protect against domain violation (default = false)</p></li><li><p><code>domain_violation_ϵ::Float64</code></p><p>(Unused) Amount about a domain violation to ignore when propagating bounds (default = 1E-9)</p></li><li><p><code>user_solver_config::Bool</code></p><p>If true, EAGO forgoes its default configuration process for subsolvers (default = false)</p></li><li><p><code>integer_abs_tol::Float64</code></p><p>Absolute tolerance used to check for integrality of decision variables (default = 1E-9)</p></li><li><p><code>integer_rel_tol::Float64</code></p><p>Relative tolerance used to check for integrality of decision variables (default = 1E-9)</p></li><li><p><code>force_global_solve::Bool</code></p><p>Ignore EAGO&#39;s ability to parse problem types and force it to run global optimization (default = false)</p></li><li><p><code>unbounded_check::Bool</code></p><p>Check that all branching variables have finite bounds and set them to +/- 1E10 if not (default = true)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/839e0fb9aafff3a935906164b6e11641f86bbf73/src/eago_optimizer/types/global_optimizer.jl#L77-L83">source</a></section></article><h2 id="Internal-Storage-Structures"><a class="docs-heading-anchor" href="#Internal-Storage-Structures">Internal Storage Structures</a><a id="Internal-Storage-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Storage-Structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.VariableInfo" href="#EAGO.VariableInfo"><code>EAGO.VariableInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct VariableInfo{T&lt;:AbstractFloat}</code></pre><p>A structure used to store information related to the bounds assigned to each variable.</p><ul><li><p><code>is_integer::Bool</code></p><p>Is the variable integer valued?</p></li><li><p><code>has_lower_bound::Bool</code></p><p>Boolean indicating whether a finite lower bound exists.</p></li><li><p><code>has_upper_bound::Bool</code></p><p>Boolean indicating whether a finite upper bound exists.</p></li><li><p><code>is_fixed::Bool</code></p><p>Boolean indicating if variable is fixed to a finite value.</p></li><li><p><code>has_constraints::Bool</code></p><p>Boolean indicating that constraints have been set</p></li><li><p><code>lower_bound::AbstractFloat</code></p><p>Lower bound. May be -Inf.</p></li><li><p><code>upper_bound::AbstractFloat</code></p><p>Upper bound. May be Inf.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/839e0fb9aafff3a935906164b6e11641f86bbf73/src/eago_optimizer/types/variable_info.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.ExtensionType" href="#EAGO.ExtensionType"><code>EAGO.ExtensionType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ExtensionType</code></pre><p>An abstract type the subtypes of which are associated with functions method overloaded for new extensions. An instance of this is the <code>DefaultExt &lt;: ExtensionType</code> structure in the EAGO <code>Optimizer</code> in the <code>ext_type</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/839e0fb9aafff3a935906164b6e11641f86bbf73/src/eago_optimizer/types/extension.jl#L1-L7">source</a></section></article><h2 id="Internal-Problem-Representations"><a class="docs-heading-anchor" href="#Internal-Problem-Representations">Internal Problem Representations</a><a id="Internal-Problem-Representations-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Problem-Representations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.InputProblem" href="#EAGO.InputProblem"><code>EAGO.InputProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct InputProblem</code></pre><p>A structure used to hold objectives and constraints added to the EAGO model. The constraints generally aren&#39;t used for relaxations.</p><p>All field information available in extended help.</p><p><strong>Extended Help</strong></p><ul><li><p><code>_variable_count::Int64</code></p><p>Count for the number of variables</p></li><li><p><code>_constraint_count::Int64</code></p><p>Count for the number of constraints</p></li><li><p><code>_vi_leq_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.LessThan{Float64}}, Tuple{MathOptInterface.VariableIndex, MathOptInterface.LessThan{Float64}}}</code></p></li><li><p><code>_vi_geq_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}, Tuple{MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}}</code></p></li><li><p><code>_vi_eq_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.EqualTo{Float64}}, Tuple{MathOptInterface.VariableIndex, MathOptInterface.EqualTo{Float64}}}</code></p></li><li><p><code>_vi_it_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}, Tuple{MathOptInterface.VariableIndex, MathOptInterface.Interval{Float64}}}</code></p></li><li><p><code>_vi_zo_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}, Tuple{MathOptInterface.VariableIndex, MathOptInterface.ZeroOne}}</code></p></li><li><p><code>_vi_int_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.VariableIndex, MathOptInterface.Integer}, Tuple{MathOptInterface.VariableIndex, MathOptInterface.Integer}}</code></p></li><li><p><code>_linear_leq_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, Tuple{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}}</code></p></li><li><p><code>_linear_geq_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, Tuple{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}</code></p></li><li><p><code>_linear_eq_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, Tuple{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}}</code></p></li><li><p><code>_quadratic_leq_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.LessThan{Float64}}, Tuple{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.LessThan{Float64}}}</code></p></li><li><p><code>_quadratic_geq_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, Tuple{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}</code></p></li><li><p><code>_quadratic_eq_constraints::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.EqualTo{Float64}}, Tuple{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.EqualTo{Float64}}}</code></p></li><li><p><code>_conic_second_order::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables, MathOptInterface.SecondOrderCone}, Tuple{MathOptInterface.VectorOfVariables, MathOptInterface.SecondOrderCone}}</code></p></li><li><p><code>_linear_leq_primal::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, Float64}</code></p></li><li><p><code>_linear_geq_primal::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, Float64}</code></p></li><li><p><code>_linear_eq_primal::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, Float64}</code></p></li><li><p><code>_quadratic_leq_primal::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.LessThan{Float64}}, Float64}</code></p></li><li><p><code>_quadratic_geq_primal::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, Float64}</code></p></li><li><p><code>_quadratic_eq_primal::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.EqualTo{Float64}}, Float64}</code></p></li><li><p><code>_linear_leq_prob_to_ip::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}}</code></p></li><li><p><code>_linear_geq_prob_to_ip::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}</code></p></li><li><p><code>_linear_eq_prob_to_ip::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}}</code></p></li><li><p><code>_quadratic_leq_prob_to_ip::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.LessThan{Float64}}, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.LessThan{Float64}}}</code></p></li><li><p><code>_quadratic_geq_prob_to_ip::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}</code></p></li><li><p><code>_quadratic_eq_prob_to_ip::Dict{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.EqualTo{Float64}}, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.EqualTo{Float64}}}</code></p></li><li><p><code>_objective::Union{Nothing, MathOptInterface.VariableIndex, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}</code></p><p>Storage for the objective function</p></li><li><p><code>_nlp_data::Union{Nothing, MathOptInterface.NLPBlockData}</code></p><p>Storage for NLP constraints (set by <code>MOI.set(m, ::NLPBlockData...)</code> in <code>moi_wrapper.jl</code>)</p></li><li><p><code>_optimization_sense::MathOptInterface.OptimizationSense</code></p><p>Objective sense information (set by <code>MOI.set(m, ::ObjectiveSense...)</code>)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/839e0fb9aafff3a935906164b6e11641f86bbf73/src/eago_optimizer/types/global_optimizer.jl#L251-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EAGO.ParsedProblem" href="#EAGO.ParsedProblem"><code>EAGO.ParsedProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ParsedProblem</code></pre><p>A structure used to store expressions and problem descriptions EAGO uses to formulate relaxed problems.</p><p>All field information available in extended help.</p><p><strong>Extended Help</strong></p><ul><li><p><code>_problem_type::Union{Nothing, EAGO.DIFF_CVX, EAGO.LP, EAGO.MILP, EAGO.MINCVX, EAGO.MISOCP, EAGO.SOCP}</code></p><p>Problem classification (set in <code>parse_classify_problem!</code>)</p></li><li><p><code>_objective_saf::MathOptInterface.ScalarAffineFunction{Float64}</code></p><p>Stores the objective and is used for constructing linear affine cuts</p></li><li><p><code>_objective::Union{Nothing, MathOptInterface.VariableIndex, EAGO.AffineFunctionIneq, EAGO.BufferedQuadraticIneq, EAGO.BufferedNonlinearFunction}</code></p><p>Storage for the objective function</p></li><li><p><code>_optimization_sense::MathOptInterface.OptimizationSense</code></p><p>Objective sense information (set by <code>MOI.set(m, ::ObjectiveSense...)</code>)</p></li><li><p><code>_saf_leq::Vector{EAGO.AffineFunctionIneq}</code></p></li><li><p><code>_saf_eq::Vector{EAGO.AffineFunctionEq}</code></p></li><li><p><code>_sqf_leq::Vector{EAGO.BufferedQuadraticIneq}</code></p></li><li><p><code>_sqf_eq::Vector{EAGO.BufferedQuadraticEq}</code></p></li><li><p><code>_conic_second_order::Vector{EAGO.BufferedSOC}</code></p></li><li><p><code>_nlp_data::Union{Nothing, MathOptInterface.NLPBlockData}</code></p></li><li><p><code>_nonlinear_constr::Vector{EAGO.BufferedNonlinearFunction}</code></p></li><li><p><code>_relaxed_evaluator::Evaluator</code></p></li><li><p><code>_variable_info::Vector{VariableInfo{Float64}}</code></p><p>Variable information (set in <code>initial_parse!</code>)</p></li><li><p><code>_variable_count::Int64</code></p><p>Count for the number of variables</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/839e0fb9aafff3a935906164b6e11641f86bbf73/src/eago_optimizer/types/global_optimizer.jl#L467-L477">source</a></section></article><h2 id="Interval-Optimizer-Subroutines"><a class="docs-heading-anchor" href="#Interval-Optimizer-Subroutines">Interval Optimizer Subroutines</a><a id="Interval-Optimizer-Subroutines-1"></a><a class="docs-heading-anchor-permalink" href="#Interval-Optimizer-Subroutines" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EAGO.initial_parse!-Union{Tuple{Optimizer{R, S, T}}, Tuple{T}, Tuple{S}, Tuple{R}} where {R, S, T}" href="#EAGO.initial_parse!-Union{Tuple{Optimizer{R, S, T}}, Tuple{T}, Tuple{S}, Tuple{R}} where {R, S, T}"><code>EAGO.initial_parse!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Translate the input problem to the working problem. Any checks or optional manipulation are left to the presolve stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PSORLab/EAGO.jl/blob/839e0fb9aafff3a935906164b6e11641f86bbf73/src/eago_optimizer/parse.jl#L411">source</a></section></article><h2 id="Extending-EAGO"><a class="docs-heading-anchor" href="#Extending-EAGO">Extending EAGO</a><a id="Extending-EAGO-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-EAGO" title="Permalink"></a></h2><p>Functionality has been included that allows for extension&#39;s to EAGO&#39;s optimizer to readily be defined. This can be done in two ways first defining a new structure which is a subtype of <code>EAGO.ExtensionType</code> and overloading methods associated with this new structure. An instance of this new structure is provided to the <code>EAGO.Optimizer</code> using the <code>ext_type</code> keyword. This results in EAGO now dispatch to the new methods rather than the generally defined methods for the parent type. For a complete example, the reader is directed to the <a href="https://github.com/PSORLab/EAGO-notebooks/blob/master/notebooks/nlpopt_interval_bnb.ipynb"><strong>interval bounding example</strong></a> and <a href="https://github.com/PSORLab/EAGO-notebooks/blob/master/notebooks/custom_quasiconvex.ipynb"><strong>quasiconvex example</strong></a>. Alternatively, the user can overload the <code>optimize_hook!</code> for this subtype which will entirely circumvent the default global solution routine. Additional information can be stored in the <code>ext</code> field of EAGO. In order to allow for compatibility between packages the user is encouraged to append their extension name to the start of each variable name (e.g. <code>newext_newdata</code>).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../McCormick/implicit/">« Relaxation of Implicit Functions</a><a class="docs-footer-nextpage" href="../bnb_back/">EAGO&#39;s Branch and Bound Routine »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 15 June 2023 20:18">Thursday 15 June 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
